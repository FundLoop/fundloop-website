create table public.audit_log (
 id bigint generated by default as identity not null,
 table_name text not null,
 action text not null,
 record_id bigint null,
 user_id uuid null default auth.uid (),
 old_data jsonb null,
 new_data jsonb null,
 created_at timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
 constraint audit_log_pkey primary key (id)
) TABLESPACE pg_default;


create table public.blog_posts (
 id bigint generated always as identity not null,
 title text not null,
 slug text not null,
 excerpt text not null,
 content text not null,
 author_id integer not null default 1,
 published_at timestamp with time zone null default now(),
 created_at timestamp with time zone null default now(),
 updated_at timestamp with time zone null default now(),
 is_support boolean null default false,
 category text null,
 subtitle text null,
 picture text null,
 constraint blog_posts_pkey primary key (id),
constraint blog_posts_author_id_fkey foreign KEY (author_id) references users (id)
) TABLESPACE pg_default;


create table public.support_requests (
  id bigint generated always as identity not null,
  name text null,
  email text null,
  subject text null,
  category text null,
  message text null,
  user_id uuid null,
  ip_address text null,
  created_at timestamp with time zone null default now(),
  constraint support_requests_pkey primary key (id),
  constraint support_requests_user_id_fkey foreign key (user_id) references users (user_id)
) TABLESPACE pg_default;




create table public.invitation_codes (
 code text not null default encode(extensions.gen_random_bytes (6), 'hex'::text),
 created_by uuid not null default auth.uid (),
 usage_count integer not null default 0,
 max_uses integer null,
 expires_at timestamp with time zone null,
 created_at timestamp with time zone not null default now(),
 constraint invitation_codes_pkey primary key (code),
 constraint fk_invitation_created_by foreign KEY (created_by) references users (user_id) on delete CASCADE
) TABLESPACE pg_default;




create table public.monthly_network_stats (
 id bigint generated always as identity not null,
 month integer not null,
 year integer not null,
 total_funds numeric not null,
 project_count integer not null,
 user_count integer not null,
 avg_salary numeric not null,
 created_at timestamp with time zone null default now(),
 updated_at timestamp with time zone null default now(),
 constraint monthly_network_stats_pkey primary key (id)
) TABLESPACE pg_default;


create trigger set_monthly_network_stats_updated_at BEFORE
update on monthly_network_stats for EACH row
execute FUNCTION set_updated_at ();




create table public.newsletter_subscribers (
 id bigint generated by default as identity not null,
 email text not null,
 subscribed_at timestamp with time zone null default (now() AT TIME ZONE 'utc'::text),
 constraint newsletter_subscribers_pkey primary key (id),
 constraint newsletter_subscribers_email_key unique (email)
) TABLESPACE pg_default;




create table public.organization_invitations (
 id bigint generated by default as identity not null,
 organization_id integer null,
 email text not null,
 role_id integer null,
 token uuid null default gen_random_uuid (),
 status_id integer null,
 created_at timestamp with time zone null default (now() AT TIME ZONE 'utc'::text),
 expires_at timestamp with time zone null default (now() AT TIME ZONE 'utc'::text),
 invited_by uuid null default auth.uid (),
 constraint organization_invitations_pkey primary key (id),
 constraint organization_invitations_organization_id_email_key unique (organization_id, email),
 constraint organization_invitations_token_key unique (token),
 constraint organization_invitations_organization_id_fkey foreign KEY (organization_id) references organizations (id) on delete CASCADE,
 constraint organization_invitations_invited_by_fkey foreign KEY (invited_by) references users (user_id),
 constraint organization_invitations_role_id_fkey foreign KEY (role_id) references ref_roles (id) on update CASCADE,
 constraint organization_invitations_status_id_fkey foreign KEY (status_id) references ref_invitation_statuses (id) on update CASCADE
) TABLESPACE pg_default;


create index IF not exists idx_organization_invitations_email on public.organization_invitations using btree (email) TABLESPACE pg_default;


create index IF not exists idx_organization_invitations_token on public.organization_invitations using btree (token) TABLESPACE pg_default;


create trigger set_organization_invitations_updated_at BEFORE
update on organization_invitations for EACH row
execute FUNCTION set_updated_at ();




create table public.organization_members (
 id bigint generated by default as identity not null,
 organization_id integer null,
 role_id integer null,
 joined_at timestamp with time zone null default (now() AT TIME ZONE 'utc'::text),
 user_id uuid null default auth.uid (),
 role_assigned_by uuid not null,
 updated_at timestamp with time zone null default (now() AT TIME ZONE 'utc'::text),
 updated_by uuid null,
 deleted_at timestamp with time zone null,
 status public.organization_members_status null default 'active'::organization_members_status,
 constraint organization_members_pkey primary key (id),
 constraint organization_members_organization_id_fkey foreign KEY (organization_id) references organizations (id) on delete CASCADE,
 constraint organization_members_role_assigned_by_fkey foreign KEY (role_assigned_by) references users (user_id) on update CASCADE,
 constraint organization_members_role_id_fkey foreign KEY (role_id) references ref_roles (id) on update CASCADE,
 constraint organization_members_user_id_fkey foreign KEY (user_id) references users (user_id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;


create index IF not exists idx_organization_members_org_id on public.organization_members using btree (organization_id) TABLESPACE pg_default;


create index IF not exists idx_active_organization_members on public.organization_members using btree (status) TABLESPACE pg_default
where
 (
   (deleted_at is null)
   and (status = 'active'::organization_members_status)
 );


create trigger audit_organization_members
after INSERT
or DELETE
or
update on organization_members for EACH row
execute FUNCTION log_changes ();


create trigger set_organization_members_updated_at BEFORE
update on organization_members for EACH row
execute FUNCTION set_updated_at ();


create trigger set_organization_members_updated_by BEFORE
update on organization_members for EACH row
execute FUNCTION set_updated_by ();




create table public.organizations (
 id bigint generated by default as identity not null,
 name text not null,
 description text null,
 logo_url text null,
 founded text null,
 website text null,
 created_at timestamp with time zone null default now(),
 updated_at timestamp without time zone null default now(),
 updated_by uuid null,
 deleted_at timestamp with time zone null,
 status public.organizations_status null default 'active'::organizations_status,
 constraint organizations_pkey primary key (id)
) TABLESPACE pg_default;


create index IF not exists idx_active_organizations on public.organizations using btree (status) TABLESPACE pg_default
where
 (
   (deleted_at is null)
   and (status = 'active'::organizations_status)
 );


create trigger audit_organizations
after INSERT
or DELETE
or
update on organizations for EACH row
execute FUNCTION log_changes ();


create trigger set_organizations_updated_at BEFORE
update on organizations for EACH row
execute FUNCTION set_updated_at ();


create trigger set_organizations_updated_by BEFORE
update on organizations for EACH row
execute FUNCTION set_updated_by ();




create table public.payment_methods (
 id bigint generated by default as identity not null,
 project_id integer null,
 method_id integer null,
 is_default boolean null default false,
 details jsonb null,
 created_at timestamp with time zone null default CURRENT_TIMESTAMP,
 updated_by uuid null,
 constraint payment_methods_pkey primary key (id),
 constraint payment_methods_method_id_fkey foreign KEY (method_id) references ref_payment_methods (id) on update CASCADE,
 constraint payment_methods_project_id_fkey foreign KEY (project_id) references projects (id) on delete CASCADE
) TABLESPACE pg_default;


create index IF not exists idx_payment_methods_project_id on public.payment_methods using btree (project_id) TABLESPACE pg_default;


create trigger audit_payment_methods
after INSERT
or DELETE
or
update on payment_methods for EACH row
execute FUNCTION log_changes ();


create trigger set_payment_methods_updated_at BEFORE
update on payment_methods for EACH row
execute FUNCTION set_updated_at ();


create trigger set_payment_methods_updated_by BEFORE
update on payment_methods for EACH row
execute FUNCTION set_updated_by ();
create table public.payments (
 id bigint generated by default as identity not null,
 project_id integer null,
 period_start date not null,
 period_end date not null,
 revenue numeric(15, 2) not null,
 payment_amount numeric(15, 2) not null,
 payment_percentage numeric(5, 2) not null,
 payment_method_id integer null,
 status_id integer null,
 created_at timestamp with time zone null default CURRENT_TIMESTAMP,
 updated_at timestamp with time zone null default (now() AT TIME ZONE 'utc'::text),
 paid_at timestamp with time zone null default (now() AT TIME ZONE 'utc'::text),
 confirmed_at timestamp with time zone null default (now() AT TIME ZONE 'utc'::text),
 notes text null,
 updated_by uuid null,
 deleted_at timestamp with time zone null,
 status public.payments_status null default 'active'::payments_status,
 constraint payments_pkey primary key (id),
 constraint payments_payment_method_id_fkey foreign KEY (payment_method_id) references ref_payment_methods (id) on update CASCADE,
 constraint payments_project_id_fkey foreign KEY (project_id) references projects (id) on delete CASCADE,
 constraint payments_status_id_fkey foreign KEY (status_id) references ref_payment_statuses (id) on update CASCADE
) TABLESPACE pg_default;


create index IF not exists idx_payments_project_id on public.payments using btree (project_id) TABLESPACE pg_default;


create index IF not exists idx_active_payments on public.payments using btree (status) TABLESPACE pg_default
where
 (
   (deleted_at is null)
   and (status = 'active'::payments_status)
 );


create trigger audit_payments
after INSERT
or DELETE
or
update on payments for EACH row
execute FUNCTION log_changes ();


create trigger set_payments_updated_at BEFORE
update on payments for EACH row
execute FUNCTION set_updated_at ();




create table public.project_categories (
 project_id integer not null,
 category_id integer not null,
 constraint project_categories_pkey primary key (project_id, category_id),
 constraint project_categories_category_id_fkey foreign KEY (category_id) references ref_categories (id) on update CASCADE,
 constraint project_categories_project_id_fkey foreign KEY (project_id) references projects (id) on delete CASCADE
) TABLESPACE pg_default;


create index IF not exists idx_project_categories_project_id on public.project_categories using btree (project_id) TABLESPACE pg_default;


create index IF not exists idx_project_categories_category_id on public.project_categories using btree (category_id) TABLESPACE pg_default;




create table public.project_stats (
 id bigint generated always as identity not null,
 project_id integer not null,
 user_count integer not null,
 monthly_revenue numeric not null,
 pledge_amount numeric not null,
 created_at timestamp with time zone null default now(),
 updated_at timestamp with time zone null default now(),
 constraint project_stats_pkey primary key (id)
) TABLESPACE pg_default;


create trigger set_project_stats_updated_at BEFORE
update on project_stats for EACH row
execute FUNCTION set_updated_at ();




create table public.projects (
 id bigint generated by default as identity not null,
 name text not null,
 description text not null,
 detailed_description text null,
 logo_url text null,
 website text null,
 organization_id integer null,
 is_public boolean null default true,
 created_at timestamp with time zone null default now(),
 payment_percentage numeric(5, 2) null default 1.00,
 payment_periodicity_id integer null,
 payment_custom_days integer null,
 default_payment_method_id integer null,
 category_id integer null,
 updated_at timestamp with time zone null default now(),
 updated_by uuid null,
 deleted_at timestamp with time zone null,
 status public.projects_status null default 'active'::projects_status,
 constraint projects_pkey primary key (id),
 constraint projects_default_payment_method_id_fkey foreign KEY (default_payment_method_id) references ref_payment_methods (id) on update CASCADE,
 constraint projects_organization_id_fkey foreign KEY (organization_id) references organizations (id) on update CASCADE,
 constraint projects_payment_periodicity_id_fkey foreign KEY (payment_periodicity_id) references ref_payment_periodicities (id) on update CASCADE
) TABLESPACE pg_default;


create index IF not exists idx_projects_organization_id on public.projects using btree (organization_id) TABLESPACE pg_default;


create index IF not exists idx_active_projects on public.projects using btree (status) TABLESPACE pg_default
where
 (
   (deleted_at is null)
   and (status = 'active'::projects_status)
 );


create trigger audit_projects
after INSERT
or DELETE
or
update on projects for EACH row
execute FUNCTION log_changes ();


create trigger set_projects_updated_at BEFORE
update on projects for EACH row
execute FUNCTION set_updated_at ();




create table public.ref_categories (
 id bigint generated by default as identity not null,
 name text not null,
 parent_category text null,
 usage_count integer not null default 1,
 created_at timestamp with time zone null default CURRENT_TIMESTAMP,
 constraint ref_categories_pkey primary key (id),
 constraint ref_categories_name_key unique (name)
) TABLESPACE pg_default;


create trigger set_ref_categories_updated_at BEFORE
update on ref_categories for EACH row
execute FUNCTION set_updated_at ();




create table public.ref_chains (
 id bigint generated by default as identity not null,
 chain_id text null,
 description text null,
 created_at timestamp with time zone not null default now(),
 constraint ref_chains_pkey primary key (id)
) TABLESPACE pg_default;




create table public.ref_genders (
 id bigint generated by default as identity not null,
 name text not null,
 display_order integer not null default 0,
 constraint ref_genders_pkey primary key (id),
 constraint ref_genders_name_key unique (name)
) TABLESPACE pg_default;
create table public.ref_interests (
 id bigint generated by default as identity not null,
 name text not null,
 category text null,
 usage_count integer not null default 1,
 created_at timestamp with time zone null default CURRENT_TIMESTAMP,
 constraint ref_interests_pkey primary key (id),
 constraint ref_interests_name_key unique (name)
) TABLESPACE pg_default;




create table public.ref_invitation_statuses (
 id bigint generated by default as identity not null,
 name text not null,
 code text not null,
 description text null,
 display_order integer not null default 0,
 constraint ref_invitation_statuses_pkey primary key (id),
 constraint ref_invitation_statuses_code_key unique (code),
 constraint ref_invitation_statuses_name_key unique (name)
) TABLESPACE pg_default;




create table public.ref_locations (
 id bigint generated by default as identity not null,
 name text not null,
 country text null,
 region text null,
 usage_count integer not null default 1,
 created_at timestamp with time zone null default (now() AT TIME ZONE 'utc'::text),
 constraint ref_locations_pkey primary key (id),
 constraint ref_locations_name_key unique (name)
) TABLESPACE pg_default;


create trigger set_ref_locations_updated_at BEFORE
update on ref_locations for EACH row
execute FUNCTION set_updated_at ();




create table public.ref_notification_types (
 id bigint generated by default as identity not null,
 name text not null,
 code text not null,
 description text null,
 display_order integer not null default 0,
 constraint ref_notification_types_pkey primary key (id),
 constraint ref_notification_types_code_key unique (code),
 constraint ref_notification_types_name_key unique (name)
) TABLESPACE pg_default;




create table public.ref_occupations (
 id bigint generated by default as identity not null,
 name text not null,
 category text null,
 usage_count integer not null default 1,
 created_at timestamp with time zone null default CURRENT_TIMESTAMP,
 constraint ref_occupations_pkey primary key (id),
 constraint ref_occupations_name_key unique (name)
) TABLESPACE pg_default;




create table public.ref_payment_methods (
 id bigint generated by default as identity not null,
 name text not null,
 code text not null,
 description text null,
 display_order integer not null default 0,
 constraint ref_payment_methods_pkey primary key (id),
 constraint ref_payment_methods_code_key unique (code),
 constraint ref_payment_methods_name_key unique (name)
) TABLESPACE pg_default;




create table public.ref_payment_periodicities (
 id bigint generated by default as identity not null,
 name text not null,
 code text not null,
 description text null,
 display_order integer not null default 0,
 constraint ref_payment_periodicities_pkey primary key (id),
 constraint ref_payment_periodicities_code_key unique (code),
 constraint ref_payment_periodicities_name_key unique (name)
) TABLESPACE pg_default;




create table public.ref_payment_statuses (
 id bigint generated by default as identity not null,
 name text not null,
 code text not null,
 description text null,
 display_order integer not null default 0,
 constraint ref_payment_statuses_pkey primary key (id),
 constraint ref_payment_statuses_code_key unique (code),
 constraint ref_payment_statuses_name_key unique (name)
) TABLESPACE pg_default;




create table public.ref_roles (
 id bigint generated by default as identity not null,
 name text not null,
 display_order integer not null default 0,
 constraint ref_roles_pkey primary key (id),
 constraint ref_roles_name_key unique (name)
) TABLESPACE pg_default;




create table public.ref_skills (
 id integer generated by default as identity not null,
 name text not null,
 category text null,
 usage_count integer not null default 1,
 created_at timestamp with time zone null default CURRENT_TIMESTAMP,
 constraint ref_skills_pkey primary key (id),
 constraint ref_skills_id_key unique (id),
 constraint ref_skills_name_key unique (name)
) TABLESPACE pg_default;


create trigger set_ref_skills_updated_at BEFORE
update on ref_skills for EACH row
execute FUNCTION set_updated_at ();




create view public.user_identities as
select
 i.user_id,
 i.provider,
 i.provider_id,
 i.identity_data,
 i.created_at,
 i.identity_data ->> 'email'::text as email
from
 auth.identities i;




create table public.user_interests (
 interest_id integer not null,
 user_id uuid null default auth.uid (),
 created_at timestamp with time zone null default (now() AT TIME ZONE 'utc'::text),
 constraint user_interests_unique unique (user_id, interest_id),
 constraint user_interests_interest_id_fkey foreign KEY (interest_id) references ref_interests (id) on update CASCADE on delete CASCADE,
 constraint user_interests_user_id_fkey foreign KEY (user_id) references users (user_id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;


create index IF not exists idx_user_interests_interest_id on public.user_interests using btree (interest_id) TABLESPACE pg_default;


create trigger set_user_interests_updated_at BEFORE
update on user_interests for EACH row
execute FUNCTION set_updated_at ();




create table public.user_notifications (
 id bigint generated by default as identity not null,
 type_id integer null,
 content jsonb not null,
 is_read boolean null default false,
 created_at timestamp with time zone null default CURRENT_TIMESTAMP,
 user_id uuid null default auth.uid (),
 read_at timestamp with time zone null default (now() AT TIME ZONE 'utc'::text),
 constraint user_notifications_pkey primary key (id),
 constraint user_notifications_type_id_fkey foreign KEY (type_id) references ref_notification_types (id) on update CASCADE,
 constraint user_notifications_user_id_fkey foreign KEY (user_id) references users (user_id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;


create trigger set_user_notifications_updated_at BEFORE
update on user_notifications for EACH row
execute FUNCTION set_updated_at ();




create table public.user_project_participation (
 id bigint generated by default as identity not null,
 project_id integer not null,
 role text not null,
 joined_at timestamp with time zone null default now(),
 updated_at timestamp with time zone null default now(),
 user_id uuid null default auth.uid (),
 constraint user_project_participation_pkey primary key (id),
 constraint user_project_participation_user_id_fkey foreign KEY (user_id) references users (user_id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;


create trigger set_user_project_participation_updated_at BEFORE
update on user_project_participation for EACH row
execute FUNCTION set_updated_at ();




create table public.user_skills (
 skill_id integer not null,
 user_id uuid not null default auth.uid (),
 constraint user_skills_pkey primary key (skill_id, user_id),
 constraint user_contribution_skills_user_id_fkey foreign KEY (user_id) references users (user_id) on update CASCADE on delete CASCADE,
 constraint user_skills_skill_id_fkey foreign KEY (skill_id) references ref_skills (id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;


create index IF not exists idx_user_contribution_skills_skill_id on public.user_skills using btree (skill_id) TABLESPACE pg_default;


create trigger set_user_skills_updated_at BEFORE
update on user_skills for EACH row
execute FUNCTION set_updated_at ();




create table public.users (
 user_id uuid not null default auth.uid (),
 cubid_id uuid null,
 full_name text not null,
 avatar_url text null,
 birth_year integer null,
 gender_id integer null,
 location_id integer null,
 occupation_id integer null,
 will_contribute boolean null default false,
 contribution_details text null,
 created_at timestamp with time zone null default (now() AT TIME ZONE 'utc'::text),
 updated_at timestamp with time zone null default now(),
 primary_email_identity uuid null,
 sequential_id integer generated by default as identity not null,
 invited_by_code text null,
 updated_by uuid null,
 deleted_at timestamp with time zone null,
 status public.users_status null default 'active'::users_status,
 constraint users_pkey primary key (user_id),
 constraint users_cubid_id_key unique (cubid_id),
 constraint users_user_id_key unique (user_id),
 constraint users_sequential_id_key unique (sequential_id),
 constraint users_occupation_id_fkey foreign KEY (occupation_id) references ref_occupations (id) on update CASCADE,
 constraint users_gender_id_fkey foreign KEY (gender_id) references ref_genders (id) on update CASCADE,
 constraint users_primary_email_identity_fkey foreign KEY (primary_email_identity) references auth.identities (id) on update CASCADE on delete CASCADE,
 constraint fk_invited_by_code foreign KEY (invited_by_code) references invitation_codes (code) on update CASCADE on delete set null,
 constraint users_user_id_fkey foreign KEY (user_id) references auth.users (id),
 constraint users_location_id_fkey foreign KEY (location_id) references ref_locations (id) on update CASCADE
) TABLESPACE pg_default;


create index IF not exists idx_active_users on public.users using btree (status) TABLESPACE pg_default
where
 (
   (deleted_at is null)
   and (status = 'active'::users_status)
 );


create trigger audit_users
after INSERT
or DELETE
or
update on users for EACH row
execute FUNCTION log_changes ();


create trigger increment_invite_code_usage
after INSERT on users for EACH row
execute FUNCTION increment_invite_usage ();


create trigger set_users_updated_at BEFORE
update on users for EACH row
execute FUNCTION set_updated_at ();


create trigger set_users_updated_by BEFORE
update on users for EACH row
execute FUNCTION set_updated_by ();




create table public.wallet_accounts (
 id bigint generated by default as identity not null,
 wallet_address text not null,
 wallet_type text not null default 'ethereum'::text,
 wallet_name text null,
 is_primary boolean null default false,
 is_removed boolean null default false,
 created_at timestamp with time zone null default (now() AT TIME ZONE 'utc'::text),
 updated_at timestamp with time zone null default (now() AT TIME ZONE 'utc'::text),
 is_for_project boolean null default false,
 project_id integer null,
 is_verified boolean null default false,
 chain_id bigint null,
 user_id uuid null default auth.uid (),
 updated_by uuid null,
 deleted_at timestamp with time zone null,
 status public.wallet_accounts_status null default 'active'::wallet_accounts_status,
 constraint wallet_accounts_pkey primary key (id),
 constraint wallet_accounts_chain_id_fkey foreign KEY (chain_id) references ref_chains (id),
 constraint wallet_accounts_project_id_fkey foreign KEY (project_id) references projects (id),
 constraint wallet_accounts_user_id_fkey foreign KEY (user_id) references users (user_id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;


create index IF not exists idx_active_wallet_accounts on public.wallet_accounts using btree (status) TABLESPACE pg_default
where
 (
   (deleted_at is null)
   and (status = 'active'::wallet_accounts_status)
 );


create index IF not exists idx_wallet_accounts_wallet_address on public.wallet_accounts using btree (wallet_address) TABLESPACE pg_default;


create trigger audit_wallet_accounts
after INSERT
or DELETE
or
update on wallet_accounts for EACH row
execute FUNCTION log_changes ();


create trigger audit_wallets
after INSERT
or DELETE
or
update on wallet_accounts for EACH row
execute FUNCTION log_changes ();


create trigger maintain_primary_wallet
after DELETE
or
update on wallet_accounts for EACH row
execute FUNCTION ensure_primary_wallet_exists ();


create trigger set_single_primary_wallet BEFORE INSERT
or
update on wallet_accounts for EACH row
execute FUNCTION ensure_single_primary_wallet ();


create trigger set_wallet_accounts_updated_at BEFORE
update on wallet_accounts for EACH row
execute FUNCTION set_updated_at ();


create trigger set_wallet_accounts_updated_by BEFORE
update on wallet_accounts for EACH row
execute FUNCTION set_updated_by ();




create table public.wallet_connections (
 id bigint generated by default as identity not null,
 account_id bigint not null,
 connected_at timestamp with time zone null default now(),
 gas_balance bigint null,
 chain_id bigint null,
 user_id uuid null,
 updated_by uuid null,
 deleted_at timestamp with time zone null,
 status public.wallet_connections_status null default 'active'::wallet_connections_status,
 constraint wallet_connections_pkey primary key (id),
 constraint wallet_connections_chain_id_fkey foreign KEY (chain_id) references ref_chains (id),
 constraint wallet_connections_user_id_fkey foreign KEY (user_id) references users (user_id) on update CASCADE on delete CASCADE,
 constraint wallet_connections_wallet_account_id_fkey foreign KEY (account_id) references wallet_accounts (id)
) TABLESPACE pg_default;


create index IF not exists idx_active_wallet_connections on public.wallet_connections using btree (status) TABLESPACE pg_default
where
 (
   (deleted_at is null)
   and (status = 'active'::wallet_connections_status)
 );


create trigger audit_wallet_connections
after INSERT
or DELETE
or
update on wallet_connections for EACH row
execute FUNCTION log_changes ();


create trigger set_wallet_connections_updated_at BEFORE
update on wallet_connections for EACH row
execute FUNCTION set_updated_at ();


create trigger set_wallet_connections_updated_by BEFORE
update on wallet_connections for EACH row
execute FUNCTION set_updated_by ();
